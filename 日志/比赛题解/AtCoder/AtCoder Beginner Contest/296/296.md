# 题解

## D

给定 $n$ 和 $m$ ，问是否存在一个最小的 $x=ab$ ，满足:

- $1 \le a \le n, \ 1 \le b \le n$
- $m \le x$

直接思考 $x$ 的取值有点困难，我们可以先枚举一个值 $a$ ，再对 $b$ 二分求值即可。

```cpp
using ill = __int128_t;

#define ll ill

void Main() {
	ll n, m;
	cin >> n >> m;

	ll ans = inf<ll>;
	for (ll i = 1; i * i <= m * 4 && i <= n; i ++) {
		ll l = 1, r = n, tag = -1;
		while (l <= r) {
			auto mid = l + ((r - l) / 2);
			if (mid * i >= m) {
				tag = mid;
				r = mid - 1;
			} else {
				l = mid + 1;
			}
		}
		if (tag != -1) {
			ans = min(ans, tag * i);
		}
	}
	if (ans == inf<ll>) ans = -1;
	cout << ans << '\n';
}
```

## E

通过对小范围数据枚举分析发现，如果数据之间能够成环，那么这个环中的所有数据即为必胜态。因此，使用拓扑排序判断有多少个点位于环中即可。

```cpp
void Main() {
	int n;
	cin >> n;

	vector<int> a(n), ind(n);
	vector adj(n, vector<int>());
	for (int i = 0; i < n; i ++) {
		cin >> a[i];
		a[i] --;
		adj[i].emplace_back(a[i]);
		ind[a[i]] ++;
	}

	queue<int> q;
	for (int i = 0; i < n; i ++)
		if (!ind[i])
			q.emplace(i);
	while (!q.empty()) {
		int from = q.front();
		q.pop();
		for (auto to : adj[from]) {
			if (-- ind[to] == 0) {
				q.emplace(to);
			}
		}
	}

	int ans = 0;
	for (int i = 0; i < n; i ++) {
		ans += ind[i] != 0;
	}
	cout << ans << '\n';
}
```