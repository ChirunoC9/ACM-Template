# 代码板子

- [代码板子](#代码板子)
  - [1 数据结构](#1-数据结构)
    - [1.1 重链剖分](#11-重链剖分)
      - [1.1.1 点权](#111-点权)
      - [1.1.2 边权转点权](#112-边权转点权)
    - [1.2 ST表](#12-st表)
    - [1.3 莫队](#13-莫队)
    - [1.4 线段树](#14-线段树)
      - [1.4.1 动态开点线段树](#141-动态开点线段树)
      - [1.4.2 可持久化线段树](#142-可持久化线段树)
        - [1.4.2.1 求区间第 K 大](#1421-求区间第-k-大)
        - [1.4.2.1 区间 MEX（在线主席树）](#1421-区间-mex在线主席树)
      - [1.4.3 势能线段树](#143-势能线段树)
      - [1.4.4 线段树合并](#144-线段树合并)
    - [1.5 二维树状数组](#15-二维树状数组)
      - [1.5.1 二维树状数组 1：单点修改，区间查询](#151-二维树状数组-1单点修改区间查询)
      - [1.5.2 二维树状数组 2：区间修改，单点查询](#152-二维树状数组-2区间修改单点查询)
      - [1.5.3 二维树状数组 3：区间修改，区间查询](#153-二维树状数组-3区间修改区间查询)
    - [1.6 珂多莉树](#16-珂多莉树)
  - [2 图论](#2-图论)
    - [2.1 树上问题](#21-树上问题)
      - [2.1.1 基环树](#211-基环树)
        - [2.1.1.1 基环树判点在环上](#2111-基环树判点在环上)
        - [2.1.1.2 基环树最大独立集](#2112-基环树最大独立集)
      - [2.1.2 树的直径](#212-树的直径)
      - [2.1.3 树的重心](#213-树的重心)
      - [2.1.4 树上启发式合并](#214-树上启发式合并)
    - [2.2 最小生成树](#22-最小生成树)
      - [2.2.1 Kruskal 重构树](#221-kruskal-重构树)
    - [2.3 三元环计数](#23-三元环计数)
    - [2.4 有向图的连通性](#24-有向图的连通性)
      - [2.4.1 Tarjan-SCC](#241-tarjan-scc)
      - [2.4.2 2-SAT 问题](#242-2-sat-问题)
    - [2.5 无向图的连通性](#25-无向图的连通性)
      - [2.5.1 点双联通分量](#251-点双联通分量)
      - [2.5.2 边双联通分量](#252-边双联通分量)
    - [2.6 拓扑排序](#26-拓扑排序)
      - [2.6.1 确定网络中边的方向](#261-确定网络中边的方向)
    - [2.7 网络流](#27-网络流)
      - [2.7.1 最大流（Dinic）](#271-最大流dinic)
      - [2.7.2 费用流（Dinic）](#272-费用流dinic)
  - [3 数学](#3-数学)
    - [3.1 扩展欧几里得](#31-扩展欧几里得)
    - [3.2 素性检验](#32-素性检验)
      - [3.2.1 模 6](#321-模-6)
    - [3.3 数论分块](#33-数论分块)
    - [3.4 筛](#34-筛)
      - [3.4.1 埃筛](#341-埃筛)
      - [3.4.2 线性筛](#342-线性筛)
    - [3.5 多项式](#35-多项式)
      - [3.5.1 FWT](#351-fwt)
    - [3.6 高斯消元](#36-高斯消元)
  - [4 字符串](#4-字符串)
    - [4.1 字符串哈希](#41-字符串哈希)
    - [4.2 KMP](#42-kmp)
    - [4.3 字典树](#43-字典树)
  - [5 动态规划](#5-动态规划)
    - [5.1 数位 DP](#51-数位-dp)
    - [5.2 SOS DP](#52-sos-dp)
  - [6 计算几何](#6-计算几何)
  - [7 杂项](#7-杂项)
    - [7.1 Fread](#71-fread)
    - [7.2 Debug](#72-debug)
    - [7.3 Int128](#73-int128)
    - [7.4 氧气和臭氧](#74-氧气和臭氧)
    - [7.5 基础板子](#75-基础板子)
    - [7.6 随机数](#76-随机数)

## 1 数据结构

### 1.1 重链剖分

#### 1.1.1 点权

```cpp
#include <bits/stdc++.h>

const int N = 1e5 + 10;
std::vector<int> edge[N];
int vw[N];
void add_edge(int from, int to) {
    edge[from].emplace_back(to);
    edge[to].emplace_back(from);
}
int dep[N], fa[N], top[N], son[N], siz[N], dfn[N], rnk[N], stamp = 0;

int n;

void build(int root) {
    auto dfs1 = [&](auto &&dfs, int from) -> void {
        son[from] = -1;
        siz[from] = 1;
        for (auto to : edge[from]) {
            if (dep[to] == -1) {
                dep[to] = dep[from] + 1;
                fa[to] = from;
                dfs(dfs, from);
                siz[from] += siz[to];
                if (son[from] == -1 || siz[to] > siz[son[from]])
                    son[from] = to;
            }
        }
    };
    auto dfs2 = [&](auto &&dfs, int from, int root) -> void {
        top[from] = root;
        dfn[from] = ++ stamp;
        rnk[stamp] = from;
        if (son[from] == -1)
            return;
        dfs(dfs, son[from], root);
        for (auto to : edge[from])
            if (to != fa[from] && to != son[from])
                dfs(dfs, to, to);
    };
    std::fill(std::begin(dep), std::end(dep), -1);
    dep[root] = stamp = 0;
    dfs1(dfs1,root);
    dfs2(dfs2,root,root);
}

int Lca(int a, int b) {
    while (top[a] != top[b]) {
        if (dep[top[a]] < dep[top[b]])  // 下面的先跳
            std::swap(a, b);
        a = fa[top[a]];
    }
    if (dep[a] > dep[b])
        std::swap(a, b);
    return a;
}

struct Info {
    int val;
    Info(int v = {}) : val(v) {}
    friend Info operator + (const Info &a, const Info &b) {
        return a.val + b.val;
    }
};
struct Node {
    Info val;
} seg[N * 4];

void rise(int id) {
    seg[id].val = seg[id * 2].val + seg[id * 2 + 1].val;
}

// l, r 指的是 dfs 序
void build(int l, int r, int id) {
    if (l == r) {
        seg[id].val = vw[rnk[l]];  // dfs序反推节点
    } else {
        int mid = l + ((r - l) >> 1);
        build(l, mid, id * 2);
        build(mid + 1, r, id * 2 + 1);
        rise(id);
    }
}

void change(int l, int r, int id, int tag, int d) {
    if (l == r) {
        seg[id].val = d;
    } else {
        int mid = l + ((r - l) >> 1);
        if (tag <= mid)
            change(l, mid, id * 2, tag, d);
        else
            change(mid + 1, r, id * 2 + 1, tag, d);
        rise(id);
    }
}

Info query(int l, int r, int id, int ql, int qr) {
    if (l == ql && r == qr) {
        return seg[id].val;
    } else {
        int mid = l + ((r - l) >> 1);
        if (qr <= mid)
            return query(l, mid, id * 2, ql, qr);
        else if (ql > mid)
            return query(mid + 1, r, id * 2 + 1, ql, qr);
        else
            return query(l, mid, id * 2, ql, mid) + query(mid + 1, r, id * 2 + 1, mid + 1, qr);
    }
}

// 查询树上节点范围
// 类似于 lca
int query(int a, int b) {
    Info ret = 0;
    while (top[a] != top[b]) {
        if (dep[top[a]] < dep[top[b]])
            std::swap(a, b);
        ret = ret + query(1, n, 1, dfn[top[a]], dfn[a]);
        a = fa[top[a]];
    }
    if (dep[a] > dep[b])
        std::swap(a, b);
    ret = ret + query(1, n, 1, dfn[a], dfn[b]);
    return ret.val;
}
```

#### 1.1.2 边权转点权

```cpp
const int N = 2e5 + 10;

struct Edge {
    int to, eid, w;
    Edge(int to = {}, int eid = {}, int w = {}) : to{to}, eid{eid}, w{w} {}
};
vector<Edge> adj[N];

void add_edge(int from, int to, int eid, int w) {
    adj[from].emplace_back(to, eid, w);
    adj[to].emplace_back(from, eid, w);
}

int dep[N], son[N], siz[N], fa[N], top[N], dfn[N], rnk[N];
// evid := edge id to v
// veid := v id to edge
int evid[N], veid[N], vw[N];
int stamp = 0;

void build(int root) {
    auto dfs1 = [&](auto &&dfs, int from, int eid, int ew) -> void {
        evid[eid] = from;
        veid[from] = eid;
        vw[from] = ew;
        siz[from] = 1;
        son[from] = -1;
        for (auto [to, eid, ew] : adj[from]) {
            if (dep[to] == -1) {
                dep[to] = dep[from] + 1;
                fa[to] = from;
                dfs(dfs, to, eid, ew);
                siz[from] += siz[to];
                if (son[from] == -1 || siz[to] > siz[son[from]]) {
                    son[from] = to;
                }
            }
        }
    };
    auto dfs2 = [&](auto &&dfs, int from, int root) -> void {
        top[from] = root;
        dfn[from] = ++ stamp;
        rnk[stamp] = from;
        if (son[from] == -1) {
            return;
        }
        dfs(dfs, son[from], root);
        for (auto [to, _, __] : adj[from]) {
            if (to != son[from] && to != fa[from]) {
                dfs(dfs, to, to);
            }
        }
    };
    std::fill(std::begin(dep), std::end(dep), -1);
    dep[root] = stamp = 0;
    dfs1(dfs1, root, 0, 0);
    dfs2(dfs2, root, root);
}

template <typename T>
struct Info {
    T val;
    Info(const T &val = {}) : val{val} {}
    friend Info operator + (const Info &a, const Info &b) {
        return Info{
            a.val + b.val
        };
    }
};
struct Node {
    Info<ll> val;
} seg[N * 4];

void rise(int id) {
    seg[id].val = seg[id * 2].val + seg[id * 2 + 1].val;
}

void build(int l, int r, int id) {
    if (l == r) {
        seg[id].val = vw[rnk[l]];
    } else {
        int mid = l + ((r - l) >> 1);
        build(l, mid, id * 2);
        build(mid + 1, r, id * 2 + 1);
        rise(id);
    }
}

void change(int l, int r, int id, int tag, ll d) {
    if (l == r) {
        seg[id].val = d;
    } else {
        int mid = l + ((r - l) >> 1);
        if (tag <= mid) {
            change(l, mid, id * 2, tag, d);
        } else {
            change(mid + 1, r, id * 2 + 1, tag, d);
        }
        rise(id);
    }
}

Info<ll> query(int l, int r, int id, int ql, int qr) {
    if (l == ql && r == qr) {
        return seg[id].val;
    } else {
        int mid = l + ((r - l) >> 1);
        if (qr <= mid) {
            return query(l, mid, id * 2, ql, qr);
        } else if (ql > mid) {
            return query(mid + 1, r, id * 2 + 1, ql, qr);
        } else {
            return query(l, mid, id * 2, ql, mid) + query(mid + 1, r, id * 2 + 1, mid + 1, qr);
        }
    }
}

void Main() {
    int n;
    cin >> n;

    auto Query = [&](int a, int b) {
        Info<ll> ret;
        while (top[a] != top[b]) {
            if (dep[top[a]] < dep[top[b]]) {
                swap(a, b);
            }
            ret = ret + query(1, n, 1, dfn[top[a]], dfn[a]);
            a = fa[top[a]];
        }
        if (dfn[a] > dfn[b]) {
            swap(a, b);
        }
        if (dfn[a] < dfn[b]) {
            ret = ret + query(1, n, 1, dfn[a] + 1, dfn[b]);
        }
        return ret;
    };
}
```

### 1.2 ST表

```cpp
auto std::ranges::view_interface<Macro>::Main() -> void {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
    }

    vector f(__lg(n) + 1, vector<int>(n + 1));
    for (int i = 1; i <= n; i ++) {
        f[0][i] = a[i];
    }
    for (int i = 1; i <= __lg(n); i ++) {
        for (int j = 1; j + (1 << i) - 1 <= n; j ++) {
            f[i][j] = max(f[i - 1][j], f[i - 1][j + (1 << (1 - j))]);
        }
    }

    auto Query = [&](int l, int r) {
        int s = __lg(r - l + 1);
        return max(f[s][l], f[s][r - (1 << s) + 1]);
    };
}
```

### 1.3 莫队

```cpp
using i64 = int64_t;

void Main() {
    int n, q;
    cin >> n >> q;

    vector<int> a(n + 1);
    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
    }
    struct Query {
        int l, r, idx;
    };
    vector<Query> que(q);
    for (int i = 0; i < q; i ++) {
        auto & [l, r, idx] = que[i];
        cin >> l >> r;
        idx = i;
    }
    sort(que.begin(), que.end(), [bk{int(sqrt(n))}](const auto &a, const auto &b) {
        if (a.l / bk != b.l / bk)
            return a.l < b.l;
        if (a.l / bk % 2)
            return a.r < b.r;
        return a.r > b.r;
    });

    vector<i64> cnt(*max_element(a.begin() + 1, a.end()) + 1);
    i64 ret = 0;
    auto calc = [](i64 cnt) -> i64 {
        if (cnt < 3)
            return 0;
        return cnt * (cnt - 1) * (cnt - 2) / 6;
    };
    auto Add = [&](int pos) {
        ret -= calc(cnt[a[pos]]);
        cnt[a[pos]] ++;
        ret += calc(cnt[a[pos]]);
    };
    auto Del = [&](int pos) {
        ret -= calc(cnt[a[pos]]);
        cnt[a[pos]] --;
        ret += calc(cnt[a[pos]]);
    };

    vector<i64> ans(q);
    int L = 1, R = 0;
    for (auto [l, r, idx] : que) {
        while (L > l)
            Add(-- L);
        while (R < r)
            Add(++ R);
        while (L < l)
            Del(L ++);
        while (R > r)
            Del(R --);
        ans[idx] = ret;
    }

    for (auto x : ans) {
        cout << x << '\n';
    }
}
```

### 1.4 线段树

#### 1.4.1 动态开点线段树

题目链接：[CF915E](https://codeforces.com/contest/915/problem/E) 。

Alex高中毕业了，他现在是大学新生。虽然他学习编程，但他还是要上体育课，这对他来说完全是一个意外。快要期末了，但是不幸的Alex的体育学分还是零蛋！

Alex可不希望被开除，他想知道到期末还有多少天的工作日，这样他就能在这些日子里修体育学分。但是在这里计算工作日可不是件容易的事情：

从现在到学期结束还有 $n$ 天(从 $1$ 到 $n$ 编号)，他们一开始都是工作日。接下来学校的工作人员会**依次**发出 $q$ 个指令，每个指令可以用三个参数 $l,r,k$ 描述：

- 如果 $k=1$，那么从 $l$ 到 $r$ （包含端点）的所有日子都变成**非**工作日。

- 如果 $k=2$，那么从 $l$ 到 $r$ （包含端点）的所有日子都变成**工作日**。

帮助Alex统计每个指令下发后，剩余的工作日天数。

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = int64_t;

struct Info {
    int val;
    Info(int val = {}) : val{val} {}
    Info operator + (const Info &a) const {
        return Info {
            val + a.val
        };
    }
};
struct Node {
    Info val;
    char lz;
    int lc, rc;
    Node(const Info &val = {}, char lz = -1, int lc = {}, int rc = {}) : val{val}, lz{lz}, lc{lc}, rc{rc} {}
};
vector<Node> seg(1);

int get_node() {
    seg.push_back(Node());
    return int(seg.size()) - 1;
}

void rise(int id) {
    seg[id].val = seg[seg[id].lc].val + seg[seg[id].rc].val;
}

void update(int l, int r, int &id, int d) {
    if (id == 0) id = get_node();
    seg[id].val = (r - l + 1) * d;
    seg[id].lz = d;
}

void down(int l, int r, int id) {
    if (seg[id].lz == -1)
        return;
    int mid = l + ((r - l) >> 1);
    update(l, mid, seg[id].lc, seg[id].lz);
    update(mid + 1, r, seg[id].rc, seg[id].lz);
    seg[id].lz = -1;
}

void modify(int l, int r, int &id, int ml, int mr, int d) {
    if (id == 0)
        id = get_node();
    if (l == ml && r == mr) {
        update(l, r, id, d);
    } else {
        int mid = l + ((r - l) >> 1);
        down(l, r, id);
        if (mr <= mid) {
            modify(l, mid, seg[id].lc, ml, mr, d);
        } else if (ml > mid) {
            modify(mid + 1, r, seg[id].rc, ml, mr, d);
        } else {
            modify(l, mid, seg[id].lc, ml, mid, d);
            modify(mid + 1, r, seg[id].rc, mid + 1, mr, d);
        }
        rise(id);
    }
}

void Main() {
    seg.reserve(int(15001000));

    int n;
    cin >> n;

    int q, root = 0;
    modify(1, n, root, 1, n, 1);
    cin >> q;
    for (int t = 1; t <= q; t ++) {
        int l, r, opt;
        cin >> l >> r >> opt;
        if (opt == 1) {
            modify(1, n, root, l, r, 0);
        } else {
            modify(1, n, root, l, r, 1);
        }
        cout << seg[root].val.val << '\n';
    }
}
```

#### 1.4.2 可持久化线段树

##### 1.4.2.1 求区间第 K 大

```cpp
struct Node {
    int val;
    int lc, rc;
    Node(int val = {}, int lc = {}, int rc = {}) : val{val}, lc{lc}, rc{rc} {}
};
vector<int> version;
vector<Node> seg{{}};

int get_node() {
    seg.emplace_back(0, 0, 0);
    return int(seg.size()) - 1;
}
void extends(int now, int pre) {
    seg[now] = seg[pre];
}
void rise(int id) {
    seg[id].val = seg[seg[id].lc].val + seg[seg[id].rc].val;
}
void update(int id, int d) {
    seg[id].val += d;
}

void build(int l, int r, int &now) {
    now = get_node();
    if (l == r) {

    } else {
        int mid = l + ((r - l) >> 1);
        build(l, mid, seg[now].lc);
        build(mid + 1, r, seg[now].rc);
        rise(now);
    }
}

void change(int l, int r, int pre, int &now, int tag, int d) {
    now = get_node();
    extends(now, pre);
    if (l == r) {
        update(now, d);
    } else {
        int mid = l + ((r - l) >> 1);
        if (tag <= mid) {
            change(l, mid, seg[pre].lc, seg[now].lc, tag, d);
        } else {
            change(mid + 1, r, seg[pre].rc, seg[now].rc, tag, d);
        }
        rise(now);
    }
}

int query_max_kth(int l, int r, int pre, int now, int kth) {
    if (l == r) {
        return l;
    } else if (l > r) {
        return -1;
    } else {
        int mid = l + ((r - l) >> 1);
        if (seg[seg[now].rc].val - seg[seg[pre].rc].val >= kth) {
            return query_max_kth(mid + 1, r, seg[pre].rc, seg[now].rc, kth);
        } else {
            return query_max_kth(l, mid, seg[pre].lc, seg[now].lc, kth - (seg[seg[now].rc].val - seg[seg[pre].lc].val));
        }
    }
}
```

##### 1.4.2.1 区间 MEX（在线主席树）

From ygg.

```cpp
const int N = 2e5 + 5;
const int M = 1e6 + 5;
struct node {
    int mi = 0;
    int l = 0, r = 0;
}tr[M * 30];
#define ls(x) (tr[x].l)
#define rs(x) (tr[x].r)
#define mi(x) tr[x].mi
int tot = 1;
int root[N], a[N], n, m;
void pushup(int x) { mi(x) = min(mi(ls(x)), mi(rs(x)));}
void upd(int last, int now, int pos, int k, int l, int r) {
    //过去的节点 现在的节点 修改的位置，k ，当前节点表示的区间[l,r]
    if (l == r) {
        mi(now) = k;
    }
    else {
        ls(now) = ls(last), rs(now) = rs(last);
        int mid = (l + r - 1) / 2;
        if (pos <= mid)
            ls(now) = ++tot, upd(ls(last), ls(now), pos, k, l, mid);
        else
            rs(now) = ++tot, upd(rs(last), rs(now), pos, k, mid + 1, r);
        pushup(now);
    }
}
void upd(int last, int now, int pos, int k) {
    upd(last, now, pos, k, 0, n);
}
int que(int x, int L, int l, int r) {
    if (l == r)return l;
    int mid = (l + r - 1) / 2;
    if (mi(ls(x)) < L)return que(ls(x), L, l, mid);
    else return que(rs(x), L, mid + 1, r);
}
void slove() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        root[i] = ++tot;
        upd(root[i - 1], root[i], a[i], i);;
    }
    while (m--) {
        int L, R; cin >> L >> R;
        cout << que(root[R], L, 0, n) << endl;
    }
}
```

#### 1.4.3 势能线段树

给定一个数列 $ a_1, a_2, \cdots, a_n $，你需要对这个序列进行如下的两种操作：

- $ 1 $ $ l $ $ r $ — 对于任意的 $ l \le i \le r$，将 $ a_i $ 修改为 $ a_i $ 的数位之和。
- $ 2 $ $ x $ — 输出 $ a_x $ .

```cpp
#include <bits/stdc++.h>
#ifndef ONLINE_JUDGE
    #include <debug.h>
#else
    #define debug(...)
#endif
using namespace std;
#define cauto const auto
#define all(x) std::begin(x), std::end(x)
#define YES std::cout << "YES\n"
#define NO std::cout << "NO\n"
#if __cplusplus >= 202002L
    namespace rgs = ranges;
#endif
template <typename T>
constexpr T inf = std::numeric_limits<T>::max() / 2;
using ll = int64_t;

const int N = 2e5 + 10;
struct Info {
    int val;
    bool ok;
    friend Info operator + (const Info &a, const Info &b) {
        return {0, a.ok && b.ok};
    }
};
struct Node {
    Info val;
} seg[N * 4];

int a[N];

void rise(int id) {
    seg[id].val = seg[id * 2].val + seg[id * 2 + 1].val;
}

void build(int l, int r, int id) {
    seg[id].val.ok = false;
    if (l == r) {
        seg[id].val.val = a[l];
        seg[id].val.ok = false;
    } else {
        int mid = l + ((r - l) >> 1);
        build(l, mid, id * 2);
        build(mid + 1, r, id * 2 + 1);
        rise(id);
    }
}

void modify(int l, int r, int id, int ml, int mr) {
    if (seg[id].val.ok)
        return;
    if (l == ml && r == mr) {
        if (l == r) {
            int tmp = seg[id].val.val;
            int ret = 0;
            while (tmp > 0) {
                ret += tmp % 10;
                tmp /= 10;
            }
            if (ret == seg[id].val.val) {
                seg[id].val.ok = true;
            } else {
                seg[id].val.val = ret;
            }
        } else {
            int mid = l + ((r - l) >> 1);
            if (!seg[id * 2].val.ok)
                modify(l, mid, id * 2, ml, mid);
            if (!seg[id * 2 + 1].val.ok)
                modify(mid + 1, r, id * 2 + 1, mid + 1, mr);
            rise(id);
        }
        return;
    }

    int mid = l + ((r - l) >> 1);
    if (mr <= mid) {
        modify(l, mid, id * 2, ml, mr);
     } else if (ml > mid) {
        modify(mid + 1, r, id * 2 + 1, ml, mr);
    } else {
        modify(l, mid, id * 2, ml, mid);
        modify(mid + 1, r, id * 2 + 1, mid + 1, mr);
    }
    rise(id);
}

Info query(int l, int r, int id, int tag) {
    if (l == r) {
        return seg[id].val;
    } else {
        int mid = l + ((r - l) >> 1);
        if (tag <= mid)
            return query(l, mid, id * 2, tag);
        return query(mid + 1, r, id * 2 + 1, tag);
    }
}

auto Solve() -> void {
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
    }
    build(1, n, 1);

    while (q --) {
        int opt;
        cin >> opt;
        if (opt == 1) {
            int l, r;
            cin >> l >> r;
            modify(1, n, 1, l, r);
        } else {
            int x;
            cin >> x;
            cout << query(1, n, 1, x).val << '\n';
        }
    }
}

auto main() -> int32_t {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    std::cout << std::fixed << std::setprecision(12);

    int32_t tot_test = 1;
    std::cin >> tot_test;

    for (int test = 1; test <= tot_test; test += 1) {
        debug(test, "-=-=-=-");
        Solve();
    }
}
```

#### 1.4.4 线段树合并

题目：[P4556 【Vani有约会】雨天的尾巴 /【模板】线段树合并](https://www.luogu.com.cn/problem/P4556)。

首先村落里的一共有 $n$ 座房屋，并形成一个树状结构。然后救济粮分 $m$ 次发放，每次选择两个房屋 $(x, y)$，然后对于 $x$ 到 $y$ 的路径上（含 $x$ 和 $y$）每座房子里发放一袋 $z$ 类型的救济粮。

然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Info {
    int val;
    Info(int val = {}) : val{val} {}
    friend Info operator + (const Info &a, const Info &b) {
        return Info {
            max(a.val, b.val)
        };
    }
};
struct Node {
    Info val;
    int lc, rc;
    Node(const Info &val = {}, int lc = {}, int rc = {}) : val{val}, lc{lc}, rc{rc} {}
};
vector<Node> seg{{}};

int GetNode() {
    seg.emplace_back(0, 0, 0);
    return int(seg.size()) - 1;
}
void extends(int now, int pre) {
    seg[now] = seg[pre];
}
void Rise(int id) {
    seg[id].val = seg[seg[id].lc].val + seg[seg[id].rc].val;
}

void Opt(int l, int r, int &now, int tag, int d) {
    if (!now) {
        now = GetNode();
    }
    if (l == r) {
        seg[now].val.val += d;
    } else {
        int mid = l + ((r - l) >> 1);
        if (tag <= mid) {
            Opt(l, mid, seg[now].lc, tag, d);
        } else {
            Opt(mid + 1, r, seg[now].rc, tag, d);
        }
        Rise(now);
    }
}

pair<int,int> Query(int l, int r, int id) {
    if (!id) {
        return {0, -1};
    }
    if (l == r) {
        return {l, seg[id].val.val};
    } else {
        int mid = l + ((r - l) >> 1);
        if (seg[seg[id].lc].val.val == seg[id].val.val) {
            return Query(l, mid, seg[id].lc);
        } else {
            return Query(mid + 1, r, seg[id].rc);
        }
    }
}

// Merge Tree b into Tree a
void Merge(int &a, int &b, int l, int r) {
    if (!a) {
        a = b;
    } else if (!b) {
        return;
    } else {
        if (l == r) {
            seg[a].val.val += seg[b].val.val;
        } else {
            int mid = l + ((r - l) >> 1);
            Merge(seg[a].lc, seg[b].lc, l, mid);
            Merge(seg[a].rc, seg[b].rc, mid + 1, r);
            Rise(a);
        }
    }
}

void Main() {
    int n, q;
    cin >> n >> q;

    vector adj(n + 1, vector<int>());
    for (int i = 1; i <= n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    vector<int> dep(n + 1, -1), dfn(n + 1), rnk(n + 1), siz(n + 1), son(n + 1), fa(n + 1, -1), top(n + 1);
    [&](int root) {
        auto dfs1 = [&](auto &&dfs, int from) -> void {
            son[from] = -1;
            siz[from] = 1;
            for (auto to : adj[from]) {
                if (dep[to] == -1) {
                    dep[to] = dep[from] + 1;
                    fa[to] = from;
                    dfs(dfs, to);
                    siz[from] += siz[to];
                    if (son[from] == -1 || siz[to] > siz[son[from]]) {
                        son[from] = to;
                    }
                }
            }
        };
        auto dfs2 = [&, stamp{0}](auto &&dfs, int from, int root) mutable -> void {
            top[from] = root;
            dfn[from] = ++ stamp;
            rnk[stamp] = from;
            if (son[from] == -1) {
                return;
            }
            dfs(dfs, son[from], root);
            for (auto to : adj[from]) {
                if (to != son[from] && to != fa[from]) {
                    dfs(dfs, to, to);
                }
            }
        };
        dep[root] = 0;
        dfs1(dfs1, root);
        dfs2(dfs2, root, root);
    }(1);

    auto GetLCA = [&](int a, int b) -> int {
        while (top[a] != top[b]) {
            if (dep[top[a]] < dep[top[b]]) {
                swap(a, b);
            }
            a = fa[top[a]];
        }
        if (dep[a] > dep[b]) {
            swap(a, b);
        }
        return a;
    };

    constexpr int L = 1, R = int(1e5);

    seg.reserve(int(2e7 + 10));
    vector<int> root(n + 1);
    for (int _ = 1; _ <= q; _ ++) {
        int x, y, z;
        cin >> x >> y >> z;

        int lca = GetLCA(x, y);
        Opt(L, R, root[x], z, 1);
        Opt(L, R, root[y], z, 1);
        Opt(L, R, root[lca], z, -1);

        if (fa[lca] != -1) {
            Opt(L, R, root[fa[lca]], z, -1);
        }
    }

    vector<int> ans(n + 1);
    auto dfs = [&](auto &&dfs, int from) -> void {
        for (auto to : adj[from]) {
            if (dep[to] == dep[from] + 1) {
                dfs(dfs, to);
                Merge(root[from], root[to], L, R);
            }
        }
        auto ret = Query(L, R, root[from]);
        if (ret.second <= 0) {
            ans[from] = 0;
        } else {
            ans[from] = ret.first;
        }
    };
    dfs(dfs, 1);

    for (auto &x : ans | views::drop(1)) {
        cout << x << '\n';
    }
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    Main();
}
```

### 1.5 二维树状数组

#### 1.5.1 二维树状数组 1：单点修改，区间查询

[LOJ #133. 二维树状数组 1：单点修改，区间查询](https://loj.ac/p/133)

给出一个 $n\times m$ 的零矩阵 $A$，你需要完成如下操作：

- $1 x y k$：表示元素 $A_{x,y}$ 自增 $k$；
- $2 a b c d$：表示询问左上角为 $(a,b)$，右下角为 $(c,d)$ 的子矩阵内所有数的和。

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = int64_t;

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    int n, m;
    cin >> n >> m;
    vector bit(n + 1, vector<i64>(m + 1));

    auto add = [&](int x, int y, i64 d) {
        for (int i = x; i <= n; i += i & -i) {
            for (int j = y; j <= m; j += j & -j) {
                bit[i][j] += d;
            }
        }
    };
    auto query = [&](int x, int y) {
        i64 ret = 0;
        for (int i = x; i; i -= i & -i) {
            for (int j = y; j; j -= j & -j) {
                ret += bit[i][j];
            }
        }
        return ret;
    };

    int opt;
    while (cin >> opt) {
        if (opt == 1) {
            int x, y, d;
            cin >> x >> y >> d;
            add(x, y, d);
        } else {
            int x1, y1, x2, y2;
            cin >> x1 >> y1 >> x2 >> y2;
            cout << query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1) << '\n';
        }
    }
}
```

#### 1.5.2 二维树状数组 2：区间修改，单点查询

给出一个 $n\times m$ 的零矩阵 $A$，你需要完成如下操作：

- $1 a b c d k$：表示左上角为 $(a,b)$，右下角为 $(c,d)$ 的子矩阵内所有数都自增 $k$；
- $2 x y$：表示询问元素 $A_{x,y}$ 的值；

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    int n, m;
    std::cin >> n >> m;
    std::vector bit(n + 1, std::vector<i64>(m + 1));

    auto add = [&](int x, int y, i64 d) {
        for (int i = x; i <= n; i += i & -i) {
            for (int j = y; j <= m; j += j & -j) {
                bit[i][j] += d;
            }
        }
    };
    auto query = [&](int x, int y) {
        i64 ret = 0;
        for (int i = x; i; i -= i & -i) {
            for (int j = y; j; j -= j & -j) {
                ret += bit[i][j];
            }
        }
        return ret;
    };

    int opt;
    while (std::cin >> opt) {
        if (opt == 1) {
            int x1, y1, x2, y2, d;
            std::cin >> x1 >> y1 >> x2 >> y2 >> d;
            add(x1, y1, d);
            add(x1, y2 + 1, -d);
            add(x2 + 1, y1, -d);
            add(x2 + 1, y2 + 1, d);
        } else {
            int x, y;
            std::cin >> x >> y;
            std::cout << query(x, y) << '\n';
        }
    }
}
```

#### 1.5.3 二维树状数组 3：区间修改，区间查询

给定一个大小为 $N \times M$ 的零矩阵，直到输入文件结束，你需要进行若干个操作，操作有两类：

- $1 a b c d x$，表示将左上角为 $(a,b)$，右下角为 $(c,d)$ 的子矩阵全部加上 $x$；
- $2 a b c d$，表示询问左上角为 $(a,b)$，右下角为 $(c,d)$ 为顶点的子矩阵的所有数字之和。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

const int N = 2050;
int n, m;
i64 a[N][N], b[N][N], c[N][N], d[N][N];

void add(int x, int y, i64 v) {
    for (int i = x; i <= n; i += i & -i) {
        for (int j = y; j <= m; j += j & -j) {
            a[i][j] += v;
            b[i][j] += (x - 1) * v;
            c[i][j] += (y - 1) * v;
            d[i][j] += (x - 1) * (y - 1) * v;
        }
    }
}
i64 query(int x, int y) {
    i64 ret = 0;
    for (int i = x; i > 0; i -= i & -i) {
        for (int j = y; j > 0; j -= j & -j) {
            ret += x * y * a[i][j]
                - y * b[i][j]
                - x * c[i][j]
                + d[i][j];
        }
    }
    return ret;
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    cin >> n >> m;
    int opt;
    while (cin >> opt) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        if (opt == 1) {
            i64 v;
            cin >> v;
            add(x1, y1, v);
            add(x1, y2 + 1, -v);
            add(x2 + 1, y1, -v);
            add(x2 + 1, y2 + 1, v);
        } else {
            cout <<
                query(x2, y2)
                - query(x1 - 1, y2)
                - query(x2, y1 - 1)
                + query(x1 - 1, y1 - 1)
            << '\n';
        }
    }
}
```

### 1.6 珂多莉树

请你写一种奇怪的数据结构，支持：

- $1$  $l$  $r$  $x$ ：将 $[l,r]$ 区间所有数加上$x$
- $2$  $l$  $r$  $x$ ：将 $[l,r]$ 区间所有数改成$x$
- $3$  $l$  $r$  $x$ ：输出将$[l,r]$ 区间从小到大排序后的第$x$ 个数是的多少(即区间第$x$ 小，数字大小相同算多次，保证 $1\leq$  $x$  $\leq$  $r-l+1$  )
- $4$  $l$  $r$  $x$  $y$ ：输出$[l,r]$ 区间每个数字的$x$ 次方的和模$y$ 的值(即($\sum^r_{i=l}a_i^x$ ) $\mod y$ )

```cpp
template <typename T>
struct BaseChthollyTree {
    int L, R;
    std::map<int,T> mp;  // 区间开始 : 数据

    // [l, r)
    BaseChthollyTree(int l, int r, const T &init_val)
        : L(l), R(r), mp{ {l - 1, init_val}, {r, init_val} } {
    }

    void Split(int x) {
        auto it = std::prev(mp.upper_bound(x));
        mp[x] = it->second;
    }

    // 删除 [l, r - 1], 建立新区间
    void Assign(int l, int r, const T &v) {
        Split(l); Split(r);
        auto it = mp.find(l);
        while (it->first != r) {
            it = mp.erase(it);
        }
        mp[l] = v;
    }

    // 其他操作
    // void Opt() {}
};

struct ChthollyTree : BaseChthollyTree<i64> {
    ChthollyTree(int l, int r, const i64 &init_val) : BaseChthollyTree<i64>(l, r, init_val) {}

    void Add(int l, int r, i64 k) {
        Split(l); Split(r);
        for (auto it = mp.find(l); it->first < r; it = std::next(it)) {
            it->second += k;
        }
    }

    i64 GetRankFromMin(int l, int r, int kth) {
        Split(l); Split(r);

        std::vector<std::pair<i64,int>> v;
        for (auto it = mp.find(l); it->first < r; it = std::next(it)) {
            v.emplace_back(it->second, next(it)->first - it->first);
        }
        std::ranges::sort(v, [](const auto &a, const auto &b) {
            if (a.first != b.first) {
                return a.first < b.first;
            }
            return a.second < b.second;
        });

        for (auto [val, cnt] : v) {
            kth -= cnt;
            if (kth <= 0) {
                return val;
            }
        }
        return -1;
    }

    i64 GetSum(int l, int r, i64 k, i64 p) {
        auto Pow = [&](i64 x, i64 i) -> i64 {
            i64 ret = 1 % p;
            x %= p;
            for (; i > 0; i >>= 1, (x *= x) %= p) {
                if (i & 1) {
                    (ret *= x) %= p;
                }
            }
            return ret;
        };

        Split(l); Split(r);
        i64 ret = 0;
        for (auto it = mp.find(l); it->first < r; it = std::next(it)) {
            int l = it->first, r = std::next(it)->first;
            i64 val = it->second;
            (ret += Pow(val, k) * (r - l) % p) %= p;
        }
        return ret;
    }
};
```

## 2 图论

### 2.1 树上问题

#### 2.1.1 基环树

##### 2.1.1.1 基环树判点在环上

拓扑排序实现。

```cpp
void Main() {
    int n;
    cin >> n;

    vector adj(n + 1, vector<int>{});
    vector<int> deg(n + 1);
    for (int i = 1; i <= n; i ++) {
        int u, v;
        cin >> u >> v;
        deg[u] ++; deg[v] ++;
    }

    queue<int> q;
    for (int i = 1; i <= n; i ++) {
        if (deg[i] == 1) {
            q.emplace(i);
        }
    }
    while (!q.empty()) {
        int from = q.front();
        q.pop();
        for (auto to : adj[from]) {
            if (deg[to] > 1) {
                deg[to] --;
                if (deg[to] == 1) {
                    q.emplace(to);
                }
            }
        }
    }

    for (int i = 1; i <= n; i ++) {
        if (deg[i] != 1) {
            cout << i << " \n"[i == n];
        }
    }
}

```

##### 2.1.1.2 基环树最大独立集

题目来源：[P2607 ZJOI2008 骑士](https://www.luogu.com.cn/problem/P2607)。

Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。

最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。

骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。

战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。

为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。

```cpp
void Main() {
    int n;
    cin >> n;

    vector<int> dad(n + 1, -1);
    auto Find = [&](auto &&Find, int x) -> int {
        if (dad[x] == -1) {
            return x;
        }
        return dad[x] = Find(Find, dad[x]);
    };
    auto Merge = [&](int a, int b) -> bool {
        a = Find(Find, a);
        b = Find(Find, b);
        if (a == b) {
            return false;
        }
        dad[a] = b;
        return true;
    };

    vector<i64> vw(n + 1);
    vector adj(n + 1, vector<int>());
    vector<pair<int,int>> loop;
    for (int i = 1; i <= n; i ++) {
        i64 w;
        int x;
        cin >> w >> x;
        vw[i] = w;
        if (Merge(i, x)) {
            adj[i].emplace_back(x);
            adj[x].emplace_back(i);
        } else {
            loop.emplace_back(x, i);
        }
    }

    debug(adj);

    vector<array<i64,2>> f(n + 1);
    vector<bool> vis(n + 1);
    auto dfs = [&](auto &&dfs, int from, int come) -> void {
        debug(from, come);
        vis[from] = true;
        f[from] = {0, vw[from]};
        for (auto to : adj[from]) {
            if (to == come)
                continue;
            dfs(dfs, to, from);
            f[from][0] += ranges::max(f[to]);
            f[from][1] += f[to][0];
        }
    };

    i64 ret = 0;
    for (auto [a, b] : loop) {
        auto work = [&](int a, int b) -> i64 {
            auto tmp = vw[a];
            vw[a] = -inf<i64>;
            dfs(dfs, b, -1);
            i64 ret = ranges::max(f[b]);
            vw[a] = tmp;
            return ret;
        };
        ret += max(work(a, b), work(b, a));
    }

    for (int i = 1; i <= n; i ++) {
        if (!vis[i]) {
            dfs(dfs, i, -1);
            ret += ranges::max(f[i]);
        }
    }

    cout << ret << '\n';
}
```

#### 2.1.2 树的直径

就是树上最长的路。

```cpp
auto std::ranges::view_interface<Macro>::Main() -> void {
    int n;
    cin >> n;

    vector adj(n + 1, vector<int>{});
    for (int i = 1; i <= n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    vector<int> dep(n + 1, -1);
    auto dfs = [&](auto &&dfs, int from, int come) -> void {
        for (auto to : adj[from]) {
            if (to != come) {
                dep[to] = dep[from] + 1;
                dfs(dfs, to, from);
            }
        }
    };
    dep[1] = 0;
    dfs(dfs, 1, 0);

    int root = -1, mx = -1;
    for (int i = 1; i <= n; i ++) {
        if (dep[i] > mx) {
            mx = dep[i];
            root = i;
        }
    }
    fill(dep.begin(), dep.end(), -1);
    dep[root] = 0;
    dfs(dfs, root, 0);

    cout << max(dep | views::drop(1)) << '\n';
}
```

#### 2.1.3 树的重心

对于一棵树，找到一个点，将其删去，剩下保留的最大连通块的节点数最小，即位树的重心。

```cpp
auto std::ranges::view_interface<Macro>::Main() -> void {
    int n;
    cin >> n;

    vector adj(n + 1, vector<int>{});
    for (int i = 1; i <= n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    vector<int> siz(n + 1);
    auto dfs1 = [&](auto &&dfs, int from, int come) -> void {
        siz[from] = 1;
        for (auto to : adj[from]) {
            if (to != come) {
                dfs(dfs, to, from);
                siz[from] += siz[to];
            }
        }
    };
    dfs1(dfs1, 1, 0);

    vector<int> f(n + 1, 0);
    auto dfs2 = [&](auto &&dfs, int from, int come) -> void {
        f[from] = n - siz[from];
        for (auto to : adj[from]) {
            if (to != come) {
                dfs(dfs, to, from);
                f[from] = max(f[from], siz[to]);
            }
        }
    };
    dfs1(dfs1, 1, 0);

    int ans = -1, mi = inf<int>;
    for (int i = 1; i <= n; i ++) {
        if (mi < f[i]) {
            ans = i;
            mi = f[i];
        }
    }

    cout << ans << '\n';
}
```

#### 2.1.4 树上启发式合并

树上启发式合并步骤如下：

1. 统计以这个点的轻儿子为根的子树信息，统计后删除所有信息；
2. 统计以这个点的重儿子为根的子树信息，统计后保留重儿子信息；
3. 再去遍历一遍轻儿子；
4. 统计这个点的信息；
5. 这个点是否要保留信息？

```cpp
#include <bits/stdc++.h>
using namespace std;

auto Main() -> void {
    int n;
    cin >> n;
    vector adj(n + 1, vector<int>());
    for (int i = 1; i <= n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    vector<int> col(n + 1);
    for (int i = 1; i <= n; i ++) {
        cin >> col[i];
    }

    vector<int> dfn(n + 1, -1), rnk(n + 1, -1), siz(n + 1), son(n + 1);
    int stamp = 0;
    auto dfs1 = [&](auto &&dfs, int from) -> void {
        dfn[from] = ++ stamp;
        rnk[stamp] = from;
        siz[from] = 1;
        son[from] = -1;
        for (auto to : adj[from]) {
            if (dfn[to] == -1) {
                dfs(dfs, to);
                siz[from] += siz[to];
                if (son[from] == -1 || siz[to] > siz[son[from]]) {
                    son[from] = to;
                }
            }
        }
    };
    dfs1(dfs1, 1);

    vector<int> col_cnt(ranges::max(col) + 1);
    int tot_col = 0;
    auto add = [&](int v) {
        if (col_cnt[col[v]] == 0) {
            tot_col ++;
        }
        col_cnt[col[v]] ++;
    };
    auto del = [&](int v) {
        col_cnt[col[v]] --;
        if (col_cnt[col[v]] == 0) {
            tot_col --;
        }
    };

    vector<int> ret(n + 1);
    auto dfs2 = [&](auto &&dfs, int from, int fa, bool keep) -> void {
        // 不保留的遍历轻儿子
        for (auto to : adj[from]) {
            if (to != fa && to != son[from]) {
                dfs(dfs, to, from, false);
            }
        }
        // 保留地遍历重儿子
        if (son[from] != -1) {
            dfs(dfs, son[from], from, true);
            for (auto to : adj[from]) {
                if (to != fa && to != son[from]) {
                    for (int i = dfn[to]; i <= dfn[to] + siz[to] - 1; i ++) {
                        add(rnk[i]);
                    }
                }
            }
        }
        // 计算该点结果
        add(from);
        ret[from] = tot_col;
        // 如果该点不保留 清空所有信息（整个的，不是这个子树的）
        if (!keep) {
            for (int i = dfn[from]; i <= dfn[from] + siz[from] - 1; i ++) {
                del(rnk[i]);
            }
        }
    };
    dfs2(dfs2, 1, 0, false);

    for (int i = 1; i <= n; i ++) {
        cout << ret[i] << '\n';
    }
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    Main();
}
```

### 2.2 最小生成树

#### 2.2.1 Kruskal 重构树

题目：[P4197 Peaks](https://www.luogu.com.cn/problem/P4197)

在 Bytemountains 有 $n$ 座山峰，每座山峰有他的高度 $h_i$。有些山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值，这个值越大表示越难走。

现在有 $q$ 组询问，每组询问询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。

```cpp
#include <bits/stdc++.h>

const int N = 2e5 + 10;

// 并查集
int dad[N];
int find(int x) {
    if (dad[x] <= -1) {
        return x;
    }
    return dad[x] = find(dad[x]);
}

// 图 adj
std::vector<int> edge[N];
int dfn[N], rnk[N], siz[N], stamp = 0, vw[N];
void add_edge(int from, int to) {
    edge[from].emplace_back(to);
    edge[to].emplace_back(from);
}

int fa[N][31];
int lg[N];

// 初始化 log_2
void init() {
    lg[0] = lg[1] = 0;
    for (int i = 2; i < N; i ++) {
        lg[i] = lg[i / 2] + 1;
    }
}

// 为树赋予 dfs 序列以维护
void dfs(int now, int dad) {
    dfn[now] = ++ stamp;
    rnk[stamp] = now;
    siz[now] = 1;

    // 用树上倍增的方式
    for (int i = 1; i <= 30; i ++) {
        fa[now][i] = fa[fa[now][i - 1]][i - 1];
    }

    for (auto nex : edge[now]) {
        if (nex != dad) {
            dfs(nex, now);
            siz[now] += siz[nex];
        }
    }
}

// 可持久化线段树
struct Node {
    int val;
    int lc, rc;
    Node() : val(0), lc(0), rc(0) {}
} seg[N << 4];
int ver[N], tt = 0;
int getNode() {
    return ++ tt;
}
void rise(int id) {
    seg[id].val = seg[ seg[id].lc ].val + seg[ seg[id].rc ].val;
}
void extend(int oid, int nid) {
    seg[nid].lc = seg[oid].lc; seg[nid].rc = seg[oid].rc;
}
void build(int l, int r, int &id) {
    id = getNode();
    if (l == r) {
        seg[id].val = -1;
    } else {
        int mid = l + ((r - l) >> 1);
        build(l, mid, seg[id].lc);
        build(mid + 1, r, seg[id].rc);
        rise(id);
    }
}
void insert(int l, int r, int oid, int &nid, int tag, int d) {
    nid = getNode();
    if (l == r) {
        seg[nid].val = seg[oid].val + d;
    } else {
        int mid = l + ((r - l) >> 1);
        extend(oid, nid);
        if (tag <= mid) {
            insert(l, mid, seg[oid].lc, seg[nid].lc, tag, d);
        } else {
            insert(mid + 1, r, seg[oid].rc, seg[nid].rc, tag, d);
        }
        rise(nid);
    }
}
int query_mx_kth(int l, int r, int lid, int rid, int kth) {
    if (seg[rid].val - seg[lid].val < kth) {
        return -1;
    } else if (l == r) {
        return l;
    } else {
        int mid = l + ((r - l) >> 1);
        int x = seg[ seg[rid].rc ].val - seg[ seg[lid].rc ].val;
        if (x >= kth) {
            return query_mx_kth(mid + 1, r, seg[lid].rc, seg[rid].rc, kth);
        } else {
            return query_mx_kth(l, mid, seg[lid].lc, seg[rid].lc, kth - x);
        }
    }
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    int n, m, q;
    std::cin >> n >> m >> q;
    std::vector<int> hei(n + 1), chei(n);
    for (int i = 1; i <= n; i ++) {
        std::cin >> hei[i];
        chei[i - 1] = hei[i];
    }
    // 离散化
    std::ranges::sort(chei);
    chei.erase(std::unique(chei.begin(), chei.end()), chei.end());
    for (int i = 1; i <= n; i ++) {
        hei[i] = std::ranges::lower_bound(chei, hei[i]) - chei.begin() + 1;
    }

    // 读取边
    std::vector<std::array<int,3>> eds(m);
    for (auto &[a, b, w] : eds) {
        std::cin >> a >> b >> w;
    }
    std::ranges::sort(eds, [](const auto &a, const auto &b) -> bool {
        return a[2] < b[2];
    });
    memset(dad, -1, sizeof(dad));
    memset(vw, -1, sizeof(vw));

    // 构建 Kruskal 重构树
    int tot = n;
    for (auto [a, b, w] : eds) {
        a = find(a); b = find(b);
        if (a != b) {
            tot ++;
            dad[a] = dad[b] = tot;
            vw[tot] = w;
            fa[a][0] = fa[b][0] = tot;
            add_edge(tot, a);
            add_edge(tot, b);
        }
    }

    init();
    for (int i = tot; i >= 1; i --) {
        if (!dfn[i]) {
            dfs(i, 0);
        }
    }

    // 建主席树
    int nn = chei.size();
    build(1, nn, ver[0]);
    for (int i = 1; i <= tot; i ++) {
        if (vw[rnk[i]] == -1) {
            insert(1, nn, ver[i - 1], ver[i], hei[rnk[i]], 1);
        } else {
            ver[i] = ver[i - 1];
        }
    }

    // 处理询问
    while (q --) {
        int v, x, k;
        std::cin >> v >> x >> k;
        if (v < 1 || v > n || k > n) {
            std::cout << -1 << '\n';
        } else {
            // 向上跳合适的节点
            for (int i = 30; i >= 0; i --) {
                if (fa[v][i] && vw[fa[v][i]] <= x) {
                    v = fa[v][i];
                }
            }

            // 可持久化权值线段树查询第 k 大值
            int ret = query_mx_kth(1, nn, ver[dfn[v] - 1], ver[dfn[v] + siz[v] - 1], k);
            if (ret == -1) {
                std::cout << -1 << '\n';
            } else {
                std::cout << chei[ret - 1] << '\n';
            }
        }
    }
}
```

### 2.3 三元环计数

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = int64_t;

auto Solve() -> void {
    int n, m;
    cin >> n >> m;

    vector<pair<int,int>> edge(m);
    vector<int> deg(n);
    for (auto &[u,v] : edge) {
        cin >> u >> v;
        u --, v --;
        deg[u] ++, deg[v] ++;
    }

    vector g(n, vector<int>());
    for (auto [u,v] : edge) {
        if (deg[u] > deg[v]) {
            g[v].emplace_back(u);
        } else if (deg[u] < deg[v]) {
            g[u].emplace_back(v);
        } else {
            g[min(u,v)].emplace_back(max(u,v));
        }
    }

    ll ans = {};
    for (int i = 0; i < n; i ++) {
        vector<bool> tod(n);
        for (auto j : g[i])
            tod[j] = true;
        for (auto j : g[i])
            for (auto k : g[j])
                ans += tod[k];
    }
    cout << ans << '\n';
}

int main() {

}
```

### 2.4 有向图的连通性

#### 2.4.1 Tarjan-SCC

题目来源：[P7251 JSOI2014 强连通图](https://www.luogu.com.cn/problem/P7251) 。

JYY 最近痴迷于图的强连通性，所以对于任何有向图，JYY 都希望增加一些边使得这个图变成强连通图。JYY现在得到了一个 $n$ 个点 $m$ 条边的有向图，所有点从 $1$ 到 $n$ 编号。

JYY 想知道：

- 在给定的图中，最多能选出多少个点，使得这些点在原图中两两可达？

- 在给定的图中，最少增加多少条边，可以使得这个图变成强连通图？

其中，一个有向图 $G(V,E)$是强连通的，当且仅当任意顶点 $a,b\in V,a\neq b$之间都存在 $a\to b$ 和 $b\to a$ 的路径。

思路：由于缩点后是一张 DAG ，让入点和出点互相连接就是最佳方案。

> Tarjan-SCC 结果的 SCC 编号是逆拓扑序。

```cpp
#include <bits/stdc++.h>
using namespace std;

void Main() {
    int n, m;
    cin >> n >> m;

    vector adj(n + 1, vector<int>());
    for (int i = 0; i < m; i ++) {
        int from, to;
        cin >> from >> to;
        adj[from].emplace_back(to);
    }

    vector<int> dfn(n + 1, -1), low(n + 1, -1), scc_id(n + 1, -1);
    vector<bool> inst(n + 1);
    vector<int> stk;
    int scc_cnt = 0, stamp = 0;
    auto dfs = [&](auto &&dfs, int from) -> void {
        dfn[from] = low[from] = ++ stamp;
        stk.emplace_back(from);
        inst[from] = true;
        for (auto to : adj[from]) {
            if (dfn[to] == -1) {
                dfs(dfs, to);
                low[from] = min(low[from], low[to]);  // 子树
            } else if (inst[to]) {
                low[from] = min(low[from], dfn[to]);  // 尝试绕过这个点
            }
        }
        // 如果这个点 low == dfn 那么表示以这个点为根的子树没法绕过这个点 产生一个 SCC
        if (low[from] == dfn[from]) {
            int now = 0;
            ++ scc_cnt;
            do {
                now = stk.back();
                stk.pop_back();
                inst[now] = false;
                scc_id[now] = scc_cnt;
            } while (now != from);
        }
    };
    for (int i = 1; i <= n; i ++) {
        if (dfn[i] == -1) {
            dfs(dfs, i);
        }
    }

    vector scc_adj(scc_cnt + 1, vector<int>());
    vector<int> scc_vcnt(scc_cnt + 1);
    for (int from = 1; from <= n; from ++) {
        scc_vcnt[scc_id[from]] ++;
        for (auto to : adj[from]) {
            if (scc_id[from] != scc_id[to]) {
                scc_adj[scc_id[from]].emplace_back(scc_id[to]);
            }
        }
    }
    for (auto &v : scc_adj | std::views::drop(1)) {
        std::ranges::sort(v);
        v.erase(unique(v.begin(), v.end()), v.end());
    }

    vector<int> ind(scc_cnt + 1), outd(scc_cnt + 1);
    for (int from = 1; from <= scc_cnt; from ++) {
        for (auto to : scc_adj[from]) {
            ind[to] ++;
        }
        outd[from] = scc_adj[from].size();
    }

    cout << std::ranges::max(scc_vcnt | std::views::drop(1)) << '\n';
    if (scc_cnt == 1) {
        cout << 0 << '\n';
    } else {
        cout << std::max(
            std::ranges::count(ind | std::views::drop(1), 0),
            std::ranges::count(outd | std::views::drop(1), 0)
        ) << '\n';
    }
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    Main();
}
```

另外的板子。

```cpp
#include <bits/stdc++.h>

using namespace std;

using LL = long long;
#define endl '\n'
using db = double;
template <class T>
using max_heap = priority_queue<T>;
template <class T>
using min_heap = priority_queue<T, vector<T>, greater<>>;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    // build graph
    vector<vector<int>> g(n + 1);

    vector<int> dfn(n + 1), low(n + 1), in_stack(n + 1), belong_scc(n + 1), sz_scc;
    stack<int> stk;
    int tot = 0, sc = 0;
    function<void(int)> dfs = [&](int u) -> void
    {
        low[u] = dfn[u] = ++tot;
        stk.push(u), in_stack[u] = 1;
        for (auto to : g[u])
        {
            if (!dfn[to])
            {
                dfs(to);
                low[u] = min(low[u], low[to]);
            }
            else if (in_stack[to])
            {
                low[u] = min(low[u], dfn[to]);
            }
        }

        if (dfn[u] == low[u])
        {
            int sz = 0;
            while (!stk.empty() && stk.top() != u)
            {
                belong_scc[stk.top()] = sc;
                sz++;
                in_stack[stk.top()] = 0;
                stk.pop();
            }
            belong_scc[stk.top()] = sc;
            sz++;
            in_stack[stk.top()] = 0;
            stk.pop();
            sz_scc.push_back(sz);
            sc++;
        }
    };
    for (int i = 1; i <= n; ++i)
        if (!dfn[i])
            dfs(i);

    return 0;
}
```

#### 2.4.2 2-SAT 问题

对于一对关系 $(u,v)$ ，其中点的状态有 $u_0,v_0, u_1, v_1$ 。若发现关系 $(u_0, v_0)$ 之间存在矛盾，那么若选择 $u_0$ 就不能选 $v_0$ ，而是选择 $v_1$ ，对于 $v_0$ 来说，同理不能选择 $u_0$ ，只可以选择 $u_1$ 。因此，我们在图中对 $(u_0,v_1)$ 和 $(v_1,u_1)$ 连一条有向边。对于其他情况和上述情况一样。

题目：[Now or later](https://www.luogu.com.cn/problem/UVA1146)

有 n 架飞机需要着陆。

每架飞机都可以选择“早着陆”和“晚着陆”两种方式之一，且必须选择一种。

第 i 架飞机的早着陆时间为 Ei，晚着陆时间为 Li，不得在其他时间着陆。

你的任务是为这些飞机安排着陆方式，使得相邻两个着陆时间间隔的最小值（称为安全间隔）应尽量大。

思路：

求的是最小间隔的最大值，那么这个可以二分求得。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
constexpr T inf = std::numeric_limits<T>::max() / 2;

void Main(int n) {
    vector<array<int,2>> tim(n);
    for (int i = 0; i < n; i ++) {
        int a, b;
        cin >> a >> b;
        tim[i] = {a, b};
    }

    auto check = [&](int mi) -> bool {
        vector<vector<int>> adj(n * 2);
        for (int i = 0; i < n; i ++) {
            for (int j = i + 1; j < n; j ++) {
                for (int k = 0; k < 2; k ++) {
                    for (int l = 0; l < 2; l ++) {
                        if (abs(tim[i][k] - tim[j][l]) < mi) {
                            adj[i * 2 + k].emplace_back((j * 2 + l) ^ 1);
                            adj[j * 2 + l].emplace_back((i * 2 + k) ^ 1);
                        }
                    }
                }
            }
        }

        vector<int> dfn(n * 2, -1), low(n * 2), stk, scc_id(n * 2);
        vector<bool> inst(n * 2);
        int scc_cnt = 0;
        auto dfs = [&, stamp{0}](auto &&dfs, int from) mutable -> void {
            dfn[from] = low[from] = ++ stamp;
            inst[from] = true;
            stk.emplace_back(from);
            for (auto to : adj[from]) {
                if (dfn[to] == -1) {
                    dfs(dfs, to);
                    low[from] = min(low[from], low[to]);
                } else if (inst[to]) {
                    low[from] = min(low[from], dfn[to]);
                }
            }
            if (dfn[from] == low[from]) {
                int now = 0;
                ++ scc_cnt;
                do {
                    now = stk.back();
                    stk.pop_back();
                    inst[now] = false;
                    scc_id[now] = scc_cnt;
                } while (now != from);
            }
        };
        for (int i = 0; i < n * 2; i ++) {
            if (dfn[i] == -1) {
                dfs(dfs, i);
            }
        }

        for (int i = 0; i < n; i ++) {
            if (scc_id[i * 2] == scc_id[i * 2 + 1]) {
                return false;
            }
        }
        return true;
    };

    int l = 0, r = inf<int>, tag = -1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (check(mid)) {
            tag = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    cout << tag << '\n';
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    int n;
    while (cin >> n)
        Main(n);
}
```

### 2.5 无向图的连通性

#### 2.5.1 点双联通分量

注意图不联通。

```cpp
#include <bits/stdc++.h>
using namespace std;

void Main() {
    int n, m;
    cin >> n >> m;

    vector adj(n + 1, vector<int>());
    for (int i = 1; i <= m; i ++) {
        int u, v;
        cin >> u >> v;
        if (u == v)  // 判掉自环
            continue;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }

    vector<int> dfn(n + 1, -1), low(n + 1, -1), stk;
    vector<bool> is_cut(n + 1);
    vector<vector<int>> v_dcc, belong_v_dcc(n + 1);  // 点双 该点位于哪个点双
    v_dcc.reserve(n);
    auto tarjan = [&, stamp{0}](auto &&dfs, int from, bool is_root) mutable -> void {
        dfn[from] = low[from] = ++ stamp;

        // 如果该点是孤立点，那么其本身算是位于一个点双
        if (adj[from].empty() && is_root) {
            v_dcc.push_back({from});
            belong_v_dcc[from].emplace_back(int(v_dcc.size()) - 1);
            return;
        }

        stk.emplace_back(from);
        int cnt = 0;  // 有多少颗子树绕不过这个点
        for (auto to : adj[from]) {
            if (dfn[to] == -1) {
                dfs(dfs, to, false);
                // 子树
                low[from] = min(low[from], low[to]);
                if (low[to] >= dfn[from]) {
                    cnt ++;
                    // 如果这个点不是搜索树的根节点，那么有个子树绕不过去，删掉这个点图连通性增加
                    // 如果这个点是搜索树的根节点，那么两颗子树绕不过去，删掉这个点图连通性增加
                    if (!is_root || cnt >= 2) {
                        is_cut[from] = true;
                    }
                    // 如果这个点是一个割点，那么自然需要回溯一下 v_dcc
                    // 如果不是（可以参考一张图中没有任何割点），那么回溯这一部分依然是一个独立的 v_dcc
                    int now = 0;
                    v_dcc.push_back({});
                    auto &new_dcc = v_dcc.back();
                    int dcc_id = int(v_dcc.size()) - 1;
                    do {
                        now = stk.back();
                        stk.pop_back();
                        new_dcc.emplace_back(now);
                        belong_v_dcc[now].emplace_back(dcc_id);
                    } while (now != to);
                    new_dcc.emplace_back(from);
                    belong_v_dcc[from].emplace_back(dcc_id);
                }
            } else {
                // 尝试绕过这个点
                low[from] = min(low[from], dfn[to]);
            }
        }
    };
    for (int i = 1; i <= n; i ++) {
        if (dfn[i] == -1) {
            tarjan(tarjan, i, true);
        }
    }

    cout << v_dcc.size() << '\n';
    for (auto &v_dcc : v_dcc) {
        cout << v_dcc.size() << ' ';
        for (auto &x : v_dcc) {
            cout << x << ' ';
        }
        cout << '\n';
    }
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    Main();
}
```

#### 2.5.2 边双联通分量

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    int n, m;
    cin >> n >> m;

    vector adj(n + 1, vector<pair<int,int>>());
    for (int i = 1; i <= m; i ++) {
        int u, v;
        cin >> u >> v;
        adj[u].emplace_back(v, i);
        adj[v].emplace_back(u, i);
    }

    vector<int> dfn(n + 1, -1), low(n + 1);
    vector<bool> is_bridge(m + 1);
    auto tarjan = [&, stamp{0}](auto &&dfs, int from, int eid) mutable -> void {
        dfn[from] = low[from] = ++ stamp;
        for (auto [to, neid] : adj[from]) {
            if (dfn[to] == -1) {
                dfs(dfs, to, neid);
                low[from] = min(low[from], low[to]);  // 子树
            } else if (neid != eid) {  // 判掉该边的返回边
                low[from] = min(low[from], dfn[to]);  // 可能的向上回溯
            }
        }
        // dfn == low 意味着搜索子树没办法绕到上面 意味着该边割掉后图连通性改变
        if (dfn[from] == low[from] && eid != -1) {
            is_bridge[eid] = true;
        }
    };
    for (int i = 1; i <= n; i ++) {
        if (dfn[i] == -1) {
            tarjan(tarjan, i, -1);
        }
    }

    // 找边双联通分量
    vector<bool> vis(n + 1);
    auto dfs = [&](auto &&dfs, int from, vector<int> &ls) -> void {
        ls.emplace_back(from);
        vis[from] = true;
        for (auto [to, neid] : adj[from]) {
            if (!is_bridge[neid] && !vis[to]) {
                dfs(dfs, to, ls);
            }
        }
    };
    vector<vector<int>> dcc;
    dcc.reserve(n);
    for (int i = 1; i <= n; i ++) {
        if (!vis[i]) {
            dcc.emplace_back(vector<int>{});
            dfs(dfs, i, dcc.back());
        }
    }

    cout << dcc.size() << '\n';
    for (auto &vec : dcc) {
        cout << vec.size() << ' ';
        for (auto v : vec) {
            cout << v << ' ';
        }
        cout << '\n';
    }
}
```

### 2.6 拓扑排序

#### 2.6.1 确定网络中边的方向

题目：[CF269C](https://www.luogu.com.cn/problem/CF269C)

现在有一个 $N$ 个点 $M$ 条边的无向图。它原本代表了一个网络流图，可是现在所有边的方向都丢失了，仅剩下流量。你需要给每个边规定一个方向，使得这个图成为一个合格的网络流图。

“合格”需要满足以下几个条件：

   1. $1$ 号点是源点，没有入度；N号点时汇点，没有出度。
   2. $2$ ~ $N-1$的每一个点，都满足入度之和等于出度之和。
   3. 定向好的有向图中没有环！特别注意第三点。

现在你需要给出这样一个定向方案，如果有多个，随意给出一个合法的即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = int64_t;

void Main() {
    int n, m;
    cin >> n >> m;
    vector adj(n + 1, vector<tuple<int,int,int,ll>>()); // 下一个点 边id 相较于输入的方向 流量
    vector<ll> ind(n + 1);
    for (int i = 0; i < m; i ++) {
        int u, v, cap;
        cin >> u >> v >> cap;
        adj[u].emplace_back(v, i, 0, cap);
        adj[v].emplace_back(u, i, 1, cap);
        ind[u] += cap; ind[v] += cap;
    }

    // 非源点 非汇点 的点其入流为所有边的流量和一半
    for (int i = 2; i < n; i ++) {
        ind[i] /= 2;
    }

    vector<int> ans(m, -1);
    queue<int> q;
    q.emplace(1);
    while (!q.empty()) {
        int from = q.front();
        q.pop();
        for (auto [to, eid, d, cap] : adj[from]) {
            // 边方向未确定 流量够入
            if (ans[eid] == -1 && ind[to] >= cap) {
                ans[eid] = d;
                ind[to] -= cap;
                if (ind[to] == 0) {
                    q.emplace(to);
                }
            }
        }
    }

    for (int i : ans) {
        cout << i << '\n';
    }
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    Main();
}
```

### 2.7 网络流

#### 2.7.1 最大流（Dinic）

```cpp
template <typename T>
constexpr T inf = std::numeric_limits<T>::max() / 2;

const int N = 1e3 + 10;

struct Edge {
    int to, cap, next;
};
vector<Edge> edge;
int head[N], cur[N], lv[N];

void init() {
    memset(head, -1, sizeof(head));
}

void add_edge(int from, int to, int cap) {
    edge.emplace_back(to, cap, head[from]); head[from] = int(edge.size()) - 1;
    edge.emplace_back(from, 0, head[to]); head[to] = int(edge.size()) - 1;  // 无向图时候为 cap
}

int MaxFlow(int s, int t) {
    auto bfs = [&]() -> bool {
        memset(lv, -1, sizeof(lv));
        copy(begin(head), end(head), cur);
        lv[s] = 0;
        queue<int> q;
        q.emplace(s);
        while (!q.empty()) {
            int from = q.front();
            q.pop();
            for (int ed = head[from]; ~ed; ed = edge[ed].next) {
                auto [to, cap, _] = edge[ed];
                if (cap > 0 && lv[to] == -1) {
                    lv[to] = lv[from] + 1;
                    q.emplace(to);
                }
            }
        }
        return lv[t] != -1;
    };
    auto dfs = [&](auto &&dfs, int from, int flow) -> int {
        if (from == t) {
            return flow;
        }
        auto lesf = flow;
        for (int &ed = cur[from]; ~ed && lesf > 0; ed = edge[ed].next) {
            auto [to, cap, _] = edge[ed];
            if (cap > 0 && lv[to] == lv[from] + 1) {
                auto ret = dfs(dfs, to, min(lesf, cap));
                lesf -= ret;
                edge[ed].cap -= ret;
                edge[ed ^ 1].cap += ret;
            }
        }
        return flow - lesf;
    };
    int flow = 0;
    while (bfs()) {
        flow += dfs(dfs, s, inf<int>);
    }
    return flow;
}
```

#### 2.7.2 费用流（Dinic）

```cpp
template <typename T>
constexpr T inf = std::numeric_limits<T>::max() / 2;

const int N = 1e3 + 10;
struct Edge {
    int to, cap, cost, next;
};
vector<Edge> edge;
int head[N], cur[N];
int dis[N];
bool vis[N];

void init() {
    memset(head, -1, sizeof head);
}

void add_edge(int from, int to, int cap, int cost) {
    edge.emplace_back(from, cap, cost, head[from]); head[from] = int(edge.size() - 1);
    edge.emplace_back(to, 0, -cost, head[to]); head[to] = int(edge.size() - 1);
}

pair<int,int> cost_flow(int s, int t) {
    auto spfa = [&]() -> bool {
        fill(begin(dis), end(dis), inf<int>);
        copy(begin(head), end(head), cur);
        dis[s] = 0;
        queue<int> q;
        q.emplace(s);
        while (!q.empty()) {
            int from = q.front();
            q.pop();
            vis[from] = false;
            for (int ed = head[from]; ~ed; ed = edge[ed].next) {
                auto [to, cap, cost, _] = edge[ed];
                if (cap > 0 && dis[to] > dis[from] + cost) {
                    dis[to] = dis[from] + cost;
                    if (!vis[to]) {
                        q.emplace(to);
                        vis[to] = true;
                    }
                }
            }
        }
        return dis[t] != inf<int>;
    };
    auto dfs = [&](auto &&dfs, int from, int flow) -> int {
        if (from == t) {
            return flow;
        }
        auto lesf = flow;
        vis[from] = true;
        for (int &ed = cur[from]; ~ed && lesf > 0; ed = edge[ed].next) {
            auto [to, cap, cost, _] = edge[ed];
            if (cap > 0 && !vis[to] && dis[to] == dis[from] + cost) {
                auto ret = dfs(dfs, to, min(cap, lesf));
                lesf -= ret;
                edge[ed].cap -= ret;
                edge[ed ^ 1].cap += ret;
            }
        }
        vis[from] = false;
        return flow - lesf;
    };

    int flow = 0, cost = 0;
    while (spfa()) {
        auto ret = dfs(dfs, s, inf<int>);
        flow += ret;
        cost += dis[t] * ret;
    }
    return {flow, cost};
}
```

## 3 数学

### 3.1 扩展欧几里得

```cpp
using i64 = int64_t;

// 参数一定为非负整数
// 如果有问题尝试 i128
array<i64,3> exgcd(i64 a, i64 b) {
    if (b == 0) {
        return {a, 1, 0};
    } else {
        auto [d, x, y] = exgcd(b, a % b);
        return {d, y, x - a / b * y};
    }
}

// 逆元
i64 inv(i64 a, i64 p) {
    auto [d, a_inv, __] = exgcd(a, p);
    if (d != 1) {
        return -1;
    }
    a_inv %= p;
    if (a_inv < p) {
        a_inv += p;
    }
    return a_inv;
}
```

### 3.2 素性检验

#### 3.2.1 模 6

```cpp
using i64 = int64_t;

bool IsPrime(i64 n) {
    if (n == 2 || n == 3 || n == 5) {
        return true;
    } else if (n < 1 || n % 2 == 0 || n % 3 == 0 || n % 5 == 0) {
        return false;
    }
    for (i64 i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}
```

### 3.3 数论分块

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = int64_t;

constexpr auto solve(ll first, ll last, ll n) -> ll {
    ll ans = 0;
    for (ll l = first; l <= last; ) {
        ll r = n / (n / l);
        ans += (r - l + 1) * (n / l);
        l = r + 1;
    }
    return ans;
}

auto main() -> int32_t {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    int t;
    cin >> t;
    while (t --) {
        ll l, r, n;
        cin >> l >> r >> n;
        cout << solve(l, r, n) << '\n';
    }
}
```

### 3.4 筛

#### 3.4.1 埃筛

```cpp
using ll = int64_t;

const int N = 1e6 + 10;
std::vector<int> prime;
std::bitset<N> no_prime;

void init() {
    no_prime[0] = no_prime[1] = 1;
    for (int i = 2; i < N; i ++) {
        if (!no_prime[i]) {
            prime.emplace_back(i);
            for (int64_t j = int64_t(i) * 2; j < N; j += i) {
                no_prime[j] = 1;
            }
        }
    }
}
```

#### 3.4.2 线性筛

```cpp
// 普通线性筛
template <int N, typename T = int32_t>
struct Euler_bitset {
    std::vector<T> prime;
    std::bitset<N> no_prime;
    Euler_bitset() : no_prime{} {
        no_prime[0] = no_prime[1] = 1;
        for (int32_t i = 2; i < N; i ++) {
            if (!no_prime[i]) prime.emplace_back(i);
            for (int64_t j : prime) {
                if (i * j >= N) break;
                no_prime[i * j] = 1;
                if (i % j == 0) break;
            }
        }
    }
    auto begin() { return prime.begin(); }
    const auto& begin() const { return prime.begin(); }
    auto end() { return prime.end(); }
    const auto& end() const { return prime.end(); }
    const auto operator [] (int idx) const { return !no_prime[idx]; }
};

// 线性筛求欧拉函数
template <int N, typename T1 = int32_t, typename T2 = int32_t>
struct Euler_phi {
    std::vector<T1> prime;
    std::bitset<N> no_prime;
    std::array<T2, N> phi;
    Euler_phi() : phi{}, no_prime{} {
        no_prime[0] = no_prime[1] = 1;
        phi[1] = 1;
        for (int32_t i = 2; i < N; i ++) {
            if (!no_prime[i]) {
                prime.emplace_back(i);
                phi[i] = T2{i - 1};
            }
            for (int64_t j : prime) {
                if (i * j >= N) break;
                no_prime[i * j] = 1;
                if (i % j) {
                    phi[i * j] = phi[i] * phi[j];
                } else {
                    phi[i * j] = phi[i] * j;
                    break;
                }
            }
        }
    }
    auto begin() { return prime.begin(); }
    const auto& begin() const { return prime.begin(); }
    auto end() { return prime.end(); }
    const auto& end() const { return prime.end(); }
    const auto operator [] (int idx) const { return !no_prime[idx]; }
};

// 线性筛求最小素因子
template <int N, typename T1 = int32_t, typename T2 = int32_t>
struct Euler_pr {
    std::vector<T1> prime;
    std::bitset<N> no_prime;
    std::array<T2, N> pr;
    Euler_pr() : pr{}, no_prime{} {
        no_prime[0] = no_prime[1] = 1;
        pr[0] = pr[1] = 1;
        for (int32_t i = 2; i < N; i ++) {
            if (!no_prime[i]) {
                prime.emplace_back(i);
                pr[i] = T2{i};
            }
            for (int64_t j : prime) {
                if (i * j >= N) break;
                no_prime[i * j] = 1;
                pr[i * j] = j;
                if (i % j == 0) break;
            }
        }
    }
    auto begin() { return prime.begin(); }
    const auto& begin() const { return prime.begin(); }
    auto end() { return prime.end(); }
    const auto& end() const { return prime.end(); }
    const auto operator [] (int idx) const { return !no_prime[idx]; }
};
```

### 3.5 多项式

#### 3.5.1 FWT

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>

const int P = 998244353;

void add(int &x, int y) {
    (x += y) >= P && (x -= P);
}
void sub(int &x, int y) {
    (x -= y) < 0 && (x += P);
}
struct FWT {
    int extend(int n) {
        int N = 1;
        for (; N < n; N <<= 1);
        return N;
    }
    void FWTor(std::vector<int> &a, bool rev) {
        int n = a.size();
        for (int l = 2, m = 1; l <= n; l <<= 1, m <<= 1) {
            for (int j = 0; j < n; j += l) for (int i = 0; i < m; i++) {
                if (!rev) add(a[i + j + m], a[i + j]);
                else sub(a[i + j + m], a[i + j]);
            }
        }
    }
    void FWTand(std::vector<int> &a, bool rev) {
        int n = a.size();
        for (int l = 2, m = 1; l <= n; l <<= 1, m <<= 1) {
            for (int j = 0; j < n; j += l) for (int i = 0; i < m; i++) {
                if (!rev) add(a[i + j], a[i + j + m]);
                else sub(a[i + j], a[i + j + m]);
            }
        }
    }
    void FWTxor(std::vector<int> &a, bool rev) {
        int n = a.size(), inv2 = (P + 1) >> 1;
        for (int l = 2, m = 1; l <= n; l <<= 1, m <<= 1) {
            for (int j = 0; j < n; j += l) for (int i = 0; i < m; i++) {
                int x = a[i + j], y = a[i + j + m];
                if (!rev) {
                    a[i + j] = (x + y) % P;
                    a[i + j + m] = (x - y + P) % P;
                } else {
                    a[i + j] = 1LL * (x + y) * inv2 % P;
                    a[i + j + m] = 1LL * (x - y + P) * inv2 % P;
                }
            }
        }
    }
    std::vector<int> Or(std::vector<int> a1, std::vector<int> a2) {
        int n = std::max(a1.size(), a2.size()), N = extend(n);
        a1.resize(N), FWTor(a1, false);
        a2.resize(N), FWTor(a2, false);
        std::vector<int> A(N);
        for (int i = 0; i < N; i++) A[i] = 1LL * a1[i] * a2[i] % P;
        FWTor(A, true);
        return A;
    }
    std::vector<int> And(std::vector<int> a1, std::vector<int> a2) {
        int n = std::max(a1.size(), a2.size()), N = extend(n);
        a1.resize(N), FWTand(a1, false);
        a2.resize(N), FWTand(a2, false);
        std::vector<int> A(N);
        for (int i = 0; i < N; i++) A[i] = 1LL * a1[i] * a2[i] % P;
        FWTand(A, true);
        return A;
    }
    std::vector<int> Xor(std::vector<int> a1, std::vector<int> a2) {
        int n = std::max(a1.size(), a2.size()), N = extend(n);
        a1.resize(N), FWTxor(a1, false);
        a2.resize(N), FWTxor(a2, false);
        std::vector<int> A(N);
        for (int i = 0; i < N; i++) A[i] = 1LL * a1[i] * a2[i] % P;
        FWTxor(A, true);
        return A;
    }
} fwt;

int main() {
    int n;
    scanf("%d", &n);
    std::vector<int> a1(n), a2(n);
    for (int i = 0; i < n; i++) scanf("%d", &a1[i]);
    for (int i = 0; i < n; i++) scanf("%d", &a2[i]);
    std::vector<int> A;
    A = fwt.Or(a1, a2);
    for (int i = 0; i < n; i++) {
        printf("%d%c", A[i], " \n"[i == n - 1]);
    }
    A = fwt.And(a1, a2);
    for (int i = 0; i < n; i++) {
        printf("%d%c", A[i], " \n"[i == n - 1]);
    }
    A = fwt.Xor(a1, a2);
    for (int i = 0; i < n; i++) {
        printf("%d%c", A[i], " \n"[i == n - 1]);
    }
    return 0;
}
```

### 3.6 高斯消元

```cpp
#include <bits/stdc++.h>
using namespace std;
const double EPS = 1E-9;
int n;
vector<vector<double>> a(n, vector<double>(n));

double det = 1;
void guess()
{
    for (int i = 0; i < n; ++i)
    {
        int k = i;
        for (int j = i + 1; j < n; ++j)
            if (abs(a[j][i]) > abs(a[k][i]))
                k = j;
        if (abs(a[k][i]) < EPS)
        {
            det = 0;
            break;
        }
        swap(a[i], a[k]);
        if (i != k)
            det = -det;
        det *= a[i][i];
        for (int j = i + 1; j < n; ++j)
            a[i][j] /= a[i][i];
        for (int j = 0; j < n; ++j)
            if (j != i && abs(a[j][i]) > EPS)
                for (int k = i + 1; k < n; ++k)
                    a[j][k] -= a[i][k] * a[j][i];
    }
}
int main()
{
    return 0;
}
```

## 4 字符串

### 4.1 字符串哈希

单模的哈希……多模的扩展一下吧。

```cpp
const int N = 1e5 + 10;
constexpr i64 BASE = 1145141, MOD = 1e9 + 7;
i64 base[N], hs[N];

void init() {
    base[0] = 1;
    for (int i = 1; i < N; i ++) {
        base[i] = base[i - 1] * BASE % MOD;
    }
}

void calc(const string &s) {
    hs[0] = 0;
    for (int i = 1; i <= s.size(); i ++) {
        hs[i] = (hs[i - 1] * BASE % MOD + s[i - 1]) % MOD;
    }
}

i64 get_hs(int l, int r) {
    return ((hs[r] - hs[l - 1] * base[r - l + 1] % MOD) % MOD + MOD) % MOD;
}

// 拼接字符串
// l1 <= r1 < l2 <= r2
i64 get_hs(int l1, int r1, int l2, int r2) {
    return (get_hs(l1, r1) * base[r2 - l2] % MOD + get_hs(l2, r2)) % MOD;
}
```

### 4.2 KMP

```cpp
#include <bits/stdc++.h>

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    std::string s, t;
    std::cin >> s >> t;

    std::vector<int> nex(t.size(), -1);
    for (int i = 1, k = -1; i < t.size(); i ++) {
        while (k > -1 && t[k + 1] != t[i])
            k = nex[k];
        if (nex[k + 1] == t[i])
            k ++;
        nex[i] = k;
    }
}
```

### 4.3 字典树

```cpp
struct Trie {
    std::vector<std::array<int,2>> trie;
    
    Trie() : trie{ {} } {}

    int GetNode() {
        trie.push_back({});
        return int(trie.size()) - 1;
    }

    void Insert(const string &s) {
        int p = 0;
        for (auto c : s) {
            int d = c - 'a';
            if (trie[p][d] == 0) {
                trie[p][d] = GetNode();
            }
            p = trie[p][d];
        }
    }
};
```

## 5 动态规划

### 5.1 数位 DP

题目：[P4999](https://www.luogu.com.cn/problem/P4999)

Mr.G最近在看一些关于数字题的书，他每天愁同学们太~~聪明~~了，所有的作业同学们都能~~做到全对~~（拿到答案）。Mr.G~~蒙在鼓里~~（心知肚明）。为了使同学们进步，Mr.G总是创造一些~~简单~~（毒瘤）题来作为作业。以下是数学作业的最后一题题干——

给出一个区间$ L $~$ R $，求$ L $到$ R $区间内**每个数的数字和**，如123这个数的数字和为1+2+3=6。

（$ 1 \leq L \leq R \leq 10^2 $）

同学们纷纷做出来了，Mr.G一看这最后一题跟摆设没区别了呀，于是他迅速修改了题目，把范围定得非常非常大，且有$ T $组数据，将最终的答案mod $ 10^9+7 $。

（$ 1 \leq L \leq R \leq 10^{18} $）
（$ 1 \leq T \leq 20  $）

同学们纷纷被难住了。但H为了备战NOIP2018，没有时间完成Mr.G的数学作业~~（其实是不想做QwQ）~~，所以Ta找到了你，希望你帮助Ta和同学完成这烦人的数学作业！

```cpp
#include <cstdint>
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>
#include <numeric>

using i64 = int64_t;

using namespace std;

constexpr i64 MOD = 1e9 + 7;

void Main() {
    i64 l, r;
    cin >> l >> r;

    vector f(20, vector<i64>(9 * 18 + 10, -1));
    auto calc = [&](i64 num) {
        vector<int> digit;
        while (num > 0) {
            digit.emplace_back(num % 10);
            num /= 10;
        }
        auto dfs = [&](auto &&dfs, int pos, int sum, bool limit, bool lead) -> i64 {
            if (pos < 0)
                return sum;
            if (!limit && !lead && f[pos][sum] != -1)
                return f[pos][sum];
            int up = limit ? digit[pos] : 9;
            i64 ret = 0;
            for (int i = 0; i <= up; i ++)
                (ret += dfs(dfs, pos - 1, sum + i, limit && i == up, lead && i == 0)) %= MOD;
            if (!limit && !lead)
                f[pos][sum] = ret;
            return ret;
        };
        return dfs(dfs, int(digit.size()) - 1, 0, true, true);
    };

    cout << ((calc(r) - calc(l - 1)) % MOD + MOD) % MOD << '\n';
}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    int test;
    cin >> test;

    while (test --> 0)
        Main();
}
```

### 5.2 SOS DP

计算 $a \& b==0$ 的对数。

```cpp
// https://ac.nowcoder.com/acm/problem/249647

#include <bits/stdc++.h>
using namespace std;
using ll = int64_t;

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);

    int n;
    cin >> n;
    vector<int> a(n);
    vector<ll> f((1 << 22), 0);
    for (auto &x : a) {
        cin >> x;
        f[x] ++;
    }

    for (int bit = 1; bit < 22; bit ++) {
        for (int i = (1 << 22) - 1; i >= 0; i --) {
            if (i & (1 << bit)) {
                f[i] += f[i ^ (1 << bit)];
            }
        }
    }

    ll ans = 0;
    for (auto x : a) {
        ans += f[x ^ ((1 << 22) - 1)];
    }
}
```

## 6 计算几何

```cpp
#include <bits/stdc++.h>

using namespace std;

using db = double;

const db eps = 1e-8;
const db pi = acos(-1.0);

int sgn(db x)
{
    if (fabs(x) < eps)
        return 0;
    return x > 0 ? 1 : -1;
}

int Dcmp(db x, db y) // 1 大于
{
    if (fabs(x - y) < eps)
        return 0;
    return x > y ? 1 : -1;
}

struct Point
{
    db x, y;
    Point() {}
    Point(db x, db y) : x(x), y(y) {}
    Point operator+(Point B) { return Point(x + B.x, y + B.y); }
    Point operator-(Point B) { return Point(x - B.x, y - B.y); }
    Point operator*(db k) { return Point(x * k, y * k); }
    Point operator/(db k) { return Point(x / k, y / k); }
    bool operator==(Point B) { return sgn(x - B.x) == 0 && sgn(y - B.y) == 0; }
    bool operator<(Point B) { return sgn(x - B.x) < 0 || (sgn(x - B.x) == 0 && sgn(y - B.y) < 0); } // 先比横坐标 再比纵坐标
};

using Vector = Point;

db Dot(Vector A, Vector B) { return A.x * B.x + A.y * B.y; }
db Len(Vector A) { return sqrt(Dot(A, A)); }
db Len2(Vector A) { return Dot(A, A); }
db Angle(Vector A, Vector B) { return acos(Dot(A, B) / (Len(A) * Len(B))); }
db Cross(Vector A, Vector B) { return A.x * B.y - A.y * B.x; }
db Area2(Point A, Point B, Point C) { return Cross(B - A, C - A); } // 三角形面积的两倍
db Distance(Point A, Point B) { return hypot(A.x - B.x, A.y - B.y); }
Vector Normal(Vector A) { return Vector(-A.y / Len(A), A.x / Len(A)); } // 单位法向量
bool Parallel(Vector A, Vector B) { return sgn(Cross(A, B)) == 0; }
Vector Rotate(Vector A, db rad) { return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); } // 逆时针旋转

struct Line
{
    Point p1, p2;
    Line() {}
    Line(Point p1, Point p2) : p1(p1), p2(p2) {}
    Line(Point p, db angle) // 已知点和倾斜角
    {
        p1 = p;
        if (sgn(angle - pi / 2) == 0)
            p2 = p1 + Point(0, 1);
        else
            p2 = Point(p1 + Point(1, tan(angle)));
    }
    // ax+by+c=0
    Line(db a, db b, db c)
    {
        if (sgn(a) == 0) // 平行于x轴
        {
            p1 = Point(0, -c / b);
            p2 = Point(1, -c / b);
        }
        else if (sgn(b) == 0) // 平行于y轴
        {
            p1 = Point(-c / a, 0);
            p2 = Point(-c / a, 1);
        }
        else // 分别令x=0,x=1  得到坐标
        {
            p1 = Point(0, -c / b);
            p2 = Point(1, (-c - a) / b);
        }
    }
};

using Segment = Line; // 线段 两端点为p1, p2

db Line_angle(Line v)
{
    db k = atan2(v.p2.y - v.p1.y, v.p2.x - v.p1.x);
    if (sgn(k) < 0)
        k += pi;
    if (sgn(k - pi) == 0)
        k -= pi;
    return k;
}

db Dis_point_line(Point p, Line v) { return fabs(Cross(p - v.p1, v.p2 - v.p1) / Distance(v.p1, v.p2)); } // 点到直线的距离 面积除以底边
db Dis_point_seg(Point p, Segment v)                                                                     // 点到线段的距离
{
    if (sgn(Dot(p - v.p1, v.p2 - v.p1)) < 0 || sgn(Dot(p - v.p2, v.p1 - v.p2)) < 0) // 取端点为最小
        return min(Distance(p, v.p1), Distance(p, v.p2));
    return Dis_point_line(p, v);
}
Point Point_line_proj(Point p, Line v) // 点到线上的投影
{
    db k = Dot(v.p2 - v.p1, p - v.p1) / Len2(v.p2 - v.p1);
    return v.p1 + (v.p2 - v.p1) * k;
};
Point Point_line_symmetry(Point p, Line v) // 点p对直线v的对称点 通过中点求
{
    Point q = Point_line_proj(p, v);
    return Point(2 * q.x - p.x, 2 * q.y - p.y);
}

int Point_Line_relation(Point p, Line v) // 点和线的位置关系 利用叉乘判断
{
    int c = sgn(Cross(p - v.p1, v.p2 - v.p1));
    if (c < 0)
        return 1; // 1 在左边
    if (c > 0)
        return 2; // 2 在右边
    return 0;     // 0 在线上
}
bool Point_on_seg(Point p, Segment v) { return sgn(Dis_point_seg(p, v)) == 0; } // 点是否在线段上

int Line_relation(Line v1, Line v2) // 两直线关系
{
    if (sgn(Cross(v1.p2 - v1.p1, v2.p2 - v2.p1)) == 0)
    {
        if (Point_Line_relation(v1.p1, v2) == 0)
            return 1; // 1 重合
        return 0;     // 0 平行
    }
    return 2; // 相交
}

Point Cross_point(Line v1, Line v2) // 求两直线的交点
{
    db s1 = Cross(v1.p2 - v1.p1, v2.p1 - v1.p1);
    db s2 = Cross(v1.p2 - v1.p1, v2.p2 - v1.p1);
    assert(sgn(s1 - s2) != 0);
    return Point(v2.p1.x * s2 - v2.p2.x * s1, v2.p1.y * s2 - v2.p2.y * s1) / (s2 - s1);
}

bool Cross_segment(Segment v1, Segment v2) // 线段是否相交
{
    db s1 = Cross(v1.p2 - v1.p1, v2.p1 - v1.p1);
    db s2 = Cross(v1.p2 - v1.p1, v2.p2 - v1.p1);
    if (sgn(s1 - s2) == 0)
        return 0;
    Point b = Point(v2.p1.x * s2 - v2.p2.x * s1, v2.p1.y * s2 - v2.p2.y * s1) / (s2 - s1);
    return Point_on_seg(b, v1) && Point_on_seg(b, v2);
}
// -----------------------平面几何:多边形-------------------
struct Polygon
{
    vector<Point> p;
    // vector<Segment> seg;

    Polygon() {}
    Polygon(vector<Point> p) : p(p) {}
    Polygon(int n) { p.resize(n); }
    Point &operator[](int i) { return p[i]; }
    int size() { return p.size(); }
};

// 判断点和任意多边形的关系 0:在外部 1:在内部 2:在边上 3:在点上
int Point_in_polygon(Point pt, Polygon &Poly)
{
    int n = Poly.size();
    auto &p = Poly.p;
    for (int i = 0; i < n; ++i)
    {
        if (pt == p[i])
            return 3;
    }

    for (int i = 0; i < n; ++i)
    {
        Line v = Line(p[i], p[(i + 1) % n]);
        if (Point_on_seg(pt, v))
            return 2;
    }

    int num = 0;
    for (int i = 0; i < n; ++i)
    {
        int j = (i + 1) % n;
        int c = sgn(Cross(pt - p[j], p[i] - p[j]));
        int u = sgn(p[i].y - pt.y);
        int v = sgn(p[j].y - pt.y);
        if (c > 0 && u < 0 && v >= 0)
            num++;
        if (c < 0 && u >= 0 && v < 0)
            num--;
    }
    return num != 0;
}

db Polygon_area(Polygon &Poly)
{
    int n = Poly.size();
    auto &p = Poly.p;
    db ans = 0;
    for (int i = 0; i < n; ++i)
        ans += Cross(p[i], p[(i + 1) % n]);
    return ans / 2;
}

Point Polygon_center(Polygon &Poly)
{
    int n = Poly.size();
    auto &p = Poly.p;
    Point ans(0, 0);
    if (sgn(Polygon_area(Poly)) == 0)
        return ans;
    for (int i = 0; i < n; ++i)
        ans = ans + (p[i] + p[(i + 1) % n]) * Cross(p[i], p[(i + 1) % n]);
    return ans;
}

Polygon Convex_hull(Polygon &Poly)
{
    int n = Poly.size();
    auto p = Poly.p;
    sort(p.begin(), p.end());
    vector<Point> ans;
    n = unique(p.begin(), p.end()) - p.begin();
    for (int i = 0; i < n; ++i)
    {
        while (ans.size() >= 2 && sgn(Cross(ans.rbegin()[0] - ans.rbegin()[1], p[i] - ans.rbegin()[1])) <= 0)
            ans.pop_back();
        ans.push_back(p[i]);
    }
    int m = ans.size();
    for (int i = n - 2; i >= 0; --i)
    {
        while (ans.size() > m && sgn(Cross(ans.rbegin()[0] - ans.rbegin()[1], p[i] - ans.rbegin()[1])) <= 0)
            ans.pop_back();
        ans.push_back(p[i]);
    }
    if (n > 1)
        ans.pop_back();
    return Polygon(ans);
}
//------------------------平面几何:圆-----------------------

struct Circle
{
    Point c;
    db r;
    Circle() {}
    Circle(Point c, db r) : c(c), r(r) {}
};

// 点和圆的关系 0:点在圆内 1:点在圆上 2:点在圆外
int Point_circle_relation(Point p, Circle C)
{
    db dst = Distance(p, C.c);
    if (sgn(dst - C.r) < 0)
        return 0;
    if (sgn(dst - C.r) == 0)
        return 1;
    return 2;
}

// 直线和圆的关系:0为直线在圆内 1为直线和圆相切 2为直线在圆外
int Line_circle_relation(Line v, Circle C)
{
    db dst = Dis_point_line(C.c, v);
    if (sgn(dst - C.r) < 0)
        return 0;
    if (sgn(dst - C.r) == 0)
        return 1;
    return 2;
}
// 线段和圆的关系:0为线段在圆内 1为线段和圆相切 2为线段在圆外
int Seg_circle_relation(Line v, Circle C)
{
    db dst = Dis_point_seg(C.c, v);
    if (sgn(dst - C.r) < 0)
        return 0;
    if (sgn(dst - C.r) == 0)
        return 1;
    return 2;
}
// 直线和圆的交点
vector<Point> Line_cross_circle(Line v, Circle C)
{
    if (Line_circle_relation(v, C) == 2)
        return vector<Point>();
    vector<Point> ans;
    Point q = Point_line_proj(C.c, v); // 圆心在直线上的投影点
    db d = Dis_point_line(C.c, v);     // 圆心到直线的距离
    db k = sqrt(C.r * C.r - d * d);
    if (sgn(k) == 0)
    {
        ans.push_back(q);
        return ans;
    }
    Vector norm_vector = (v.p2 - v.p1) / Len(v.p2 - v.p1);
    ans.push_back(q + norm_vector * k);
    ans.push_back(q - norm_vector * k);
    return ans;
}

```

## 7 杂项

### 7.1 Fread

```cpp
struct Fread {
    char *p1, *p2, buf[100000];
    constexpr char nextchar() noexcept {
        return (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++);
    }
    template <class T> constexpr void read(T &val) noexcept {
        val = 0;
        int f = 1;
        char ch = nextchar();
        while (ch < 48 || ch > 57) {
            if (ch == '-') {
                f = -1;
            }
            ch = nextchar();
        }
        while (ch >= 48 && ch <= 57) {
            val = val * 10 + ch - 48, ch = nextchar();
        }
        val *= f;
    }
    template <class T> constexpr Fread& operator >> (T &val) noexcept {
        this->read(val);
        return *this;
    }
} fin;

struct Fwrite {
    template <class T> constexpr void write(T x) {
        if (x < 0) {
            putchar('-');
            x = -x;
        }
        if (x > 9)
            write(x / 10);
        putchar(x % 10 + '0');
    }
    constexpr void write(char x) { putchar(x); }
    constexpr void write(const char *x) { puts(x); }
    // constexpr void write(const std::string &str) { puts(str.c_str()); }
    template <class T> constexpr Fwrite& operator << (const T &x) {
        this->write(x);
        return *this;
    }
} fout;
```

### 7.2 Debug

```cpp
#ifndef ONLINE_JUDGE
#define debug(X) std::cerr << #X << "=" << X << "\n"
#else
#define debug(...)
#endif
```

### 7.3 Int128

```cpp
std::istream& operator >> (std::istream &is, __int128_t &x) {
    x = 0;
    std::string s; is >> s;
    bool flag = false;
    for (auto ch : s)
        if (ch == '-') flag = true;
        else x = x * 10 + (ch ^ 48);
    if (flag) x = -x;
    return is;
}
std::ostream& operator << (std::ostream &os, __int128_t x) {
    if (x == 0) return os << '0';
    bool flag = false;
    if (x < 0)
        x = -x, flag = true;
    std::string s;
    while (x > 0)
        s += x % 10 + '0', x /= 10;
    if (flag) s += '-';
    std::reverse(s.begin(), s.end());
    return os << s;
}
using i128 = __int128_t;
```

### 7.4 氧气和臭氧

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
```

### 7.5 基础板子

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = int64_t;
using i128 = __int128_t;
using db = double;
using ld = long double;

void Main() {

}

int main() {
    std::cin.tie(nullptr)->sync_with_stdio(false);
    std::cout << std::fixed << std::setprecision(15);

    int t = 1;
    std::cin >> t;
    for (int rp = 1; t --> 0; rp ++) {
        Main();
    }
}
```

### 7.6 随机数

```cpp
std::mt19937 mt_rand(std::chrono::system_clock::now().time_since_epoch().count());
```
